#include "/Engine/Public/Platform.ush"

RWTexture2D<float4> OutputTexture;
Texture2D FacePX;
Texture2D FaceNX;
Texture2D FacePY;
Texture2D FaceNY;
Texture2D FacePZ;
Texture2D FaceNZ;
SamplerState FaceSampler;

cbuffer Parameters
{
    int2 OutputResolution;
    int EyeIndex;
    int GammaMode;
    float Padding;
};

float4 SampleCubemap(float3 Direction)
{
    float3 AbsDirection = abs(Direction);
    float2 UV;
    float4 Sampled;

    if (AbsDirection.x >= AbsDirection.y && AbsDirection.x >= AbsDirection.z)
    {
        if (Direction.x > 0)
        {
            UV = float2(-Direction.z, Direction.y) / AbsDirection.x;
            Sampled = FacePX.SampleLevel(FaceSampler, UV * 0.5 + 0.5, 0);
        }
        else
        {
            UV = float2(Direction.z, Direction.y) / AbsDirection.x;
            Sampled = FaceNX.SampleLevel(FaceSampler, UV * 0.5 + 0.5, 0);
        }
    }
    else if (AbsDirection.y >= AbsDirection.x && AbsDirection.y >= AbsDirection.z)
    {
        if (Direction.y > 0)
        {
            UV = float2(Direction.x, -Direction.z) / AbsDirection.y;
            Sampled = FacePY.SampleLevel(FaceSampler, UV * 0.5 + 0.5, 0);
        }
        else
        {
            UV = float2(Direction.x, Direction.z) / AbsDirection.y;
            Sampled = FaceNY.SampleLevel(FaceSampler, UV * 0.5 + 0.5, 0);
        }
    }
    else
    {
        if (Direction.z > 0)
        {
            UV = float2(Direction.x, Direction.y) / AbsDirection.z;
            Sampled = FacePZ.SampleLevel(FaceSampler, UV * 0.5 + 0.5, 0);
        }
        else
        {
            UV = float2(-Direction.x, Direction.y) / AbsDirection.z;
            Sampled = FaceNZ.SampleLevel(FaceSampler, UV * 0.5 + 0.5, 0);
        }
    }

    return Sampled;
}

float3 ApplySeamFix(float3 Direction, float FixAmount)
{
    if (FixAmount <= 0.0)
    {
        return Direction;
    }

    float3 AbsDirection = abs(Direction);
    float MaxComponent = max(max(AbsDirection.x, AbsDirection.y), AbsDirection.z);
    if (MaxComponent <= 0.0)
    {
        return Direction;
    }

    float3 Normalized = Direction / MaxComponent;
    float Scale = saturate(1.0 - FixAmount);
    Normalized *= Scale;
    return normalize(Normalized);
}

float3 ApplyGammaByMode(float3 LinearColor, int Mode)
{
    if (Mode == 0)
    {
        float3 Clamped = saturate(LinearColor);
        return pow(Clamped, 1.0 / 2.2);
    }

    return saturate(LinearColor);
}

float3 ApplyGamma(float3 LinearColor)
{
    return ApplyGammaByMode(LinearColor, GammaMode);
}

[numthreads(8, 8, 1)]
void MainCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    if (DispatchThreadId.x >= OutputResolution.x || DispatchThreadId.y >= OutputResolution.y)
    {
        return;
    }

    float2 PixelCoord = (float2(DispatchThreadId.xy) + 0.5) / float2(OutputResolution);

    float Phi = (PixelCoord.x * 2.0 - 1.0) * PI;
    float Theta = (0.5 - PixelCoord.y) * PI;

    float3 Direction;
    Direction.x = cos(Theta) * sin(Phi);
    Direction.y = sin(Theta);
    Direction.z = cos(Theta) * cos(Phi);

    Direction = ApplySeamFix(Direction, Padding);
    float4 Sampled = SampleCubemap(normalize(Direction));
    float3 Color = ApplyGamma(Sampled.rgb);

    OutputTexture[DispatchThreadId.xy] = float4(Color, Sampled.a);
}

Texture2D<float4> NVENCSourceTexture;
RWTexture2D<uint4> NVENCOutputTexture;

cbuffer NVENCParameters
{
    int2 NVENCOutputResolution;
    int2 NVENCSourceResolution;
    int NVENCGammaMode;
    int2 NVENCOffset;
};

float3 SampleNVENCSourceColor(int2 SourceCoord)
{
    float4 Sampled = NVENCSourceTexture.Load(int3(SourceCoord, 0));
    float3 GammaCorrected = ApplyGammaByMode(Sampled.rgb, NVENCGammaMode);
    return saturate(GammaCorrected);
}

float EncodeLuma8(float3 RGB)
{
    float YLinear = dot(RGB, float3(0.2126f, 0.7152f, 0.0722f));
    float YByte = 16.0f + 219.0f * YLinear;
    return clamp(YByte, 0.0f, 255.0f);
}

float EncodeLuma10(float3 RGB)
{
    float YLinear = dot(RGB, float3(0.2126f, 0.7152f, 0.0722f));
    float YTenBit = 64.0f + 876.0f * YLinear;
    return clamp(YTenBit, 0.0f, 1023.0f);
}

float2 EncodeChroma8(float3 RGB)
{
    float ULinear = dot(RGB, float3(-0.1146f, -0.3854f, 0.5000f));
    float VLinear = dot(RGB, float3(0.5000f, -0.4542f, -0.0458f));
    float UByte = 128.0f + 224.0f * ULinear;
    float VByte = 128.0f + 224.0f * VLinear;
    return clamp(float2(UByte, VByte), 0.0f, 255.0f);
}

float2 EncodeChroma10(float3 RGB)
{
    float ULinear = dot(RGB, float3(-0.1146f, -0.3854f, 0.5000f));
    float VLinear = dot(RGB, float3(0.5000f, -0.4542f, -0.0458f));
    float UTenBit = 512.0f + 896.0f * ULinear;
    float VTenBit = 512.0f + 896.0f * VLinear;
    return clamp(float2(UTenBit, VTenBit), 0.0f, 1023.0f);
}

[numthreads(8, 8, 1)]
void ConvertToNVENCBGRA(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    if (DispatchThreadId.x >= NVENCSourceResolution.x || DispatchThreadId.y >= NVENCSourceResolution.y)
    {
        return;
    }

    const int2 SourceCoord = int2(DispatchThreadId.xy);
    const int2 DestCoord = SourceCoord + NVENCOffset;

    if (DestCoord.x >= NVENCOutputResolution.x || DestCoord.y >= NVENCOutputResolution.y)
    {
        return;
    }

    float3 Color = SampleNVENCSourceColor(SourceCoord);
    uint3 Quantized = (uint3)round(Color * 255.0f);
    float AlphaFloat = saturate(NVENCSourceTexture.Load(int3(SourceCoord, 0)).a);
    uint Alpha = (uint)round(AlphaFloat * 255.0f);

    // NVENC expects BGRA ordering when submitting ARGB textures.
    NVENCOutputTexture[DestCoord] = uint4(Quantized.b, Quantized.g, Quantized.r, Alpha);
}

RWTexture2D<uint> NVENCPlanarYTexture;
RWTexture2D<uint2> NVENCPlanarUVTexture;

cbuffer NVENCPlanarParameters
{
    int2 NVENCYResolution;
    int2 NVENCSourceResolutionPlanar;
    int2 NVENCOffsetPlanar;
    int2 NVENCChromaResolution;
    int2 NVENCChromaOffset;
    int NVENCPlanarGammaMode;
    int NVENCIs10Bit;
};

void WritePlanarLuma(int2 DestCoord, float EncodedValue)
{
    if (DestCoord.x < 0 || DestCoord.y < 0 || DestCoord.x >= NVENCYResolution.x || DestCoord.y >= NVENCYResolution.y)
    {
        return;
    }
    NVENCPlanarYTexture[DestCoord] = (uint)round(EncodedValue);
}

[numthreads(8, 8, 1)]
void ConvertToNVENCPlanar(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    if (DispatchThreadId.x >= NVENCChromaResolution.x || DispatchThreadId.y >= NVENCChromaResolution.y)
    {
        return;
    }

    const int2 BlockCoord = int2(DispatchThreadId.xy);
    const int2 SourceBase = BlockCoord * 2;

    if (SourceBase.x >= NVENCSourceResolutionPlanar.x || SourceBase.y >= NVENCSourceResolutionPlanar.y)
    {
        return;
    }

    int2 SampleCoords[4];
    SampleCoords[0] = SourceBase;
    SampleCoords[1] = SourceBase + int2(1, 0);
    SampleCoords[2] = SourceBase + int2(0, 1);
    SampleCoords[3] = SourceBase + int2(1, 1);

    float3 Colors[4];
    [unroll]
    for (int Index = 0; Index < 4; ++Index)
    {
        int2 Clamped = SampleCoords[Index];
        Clamped.x = clamp(Clamped.x, 0, NVENCSourceResolutionPlanar.x - 1);
        Clamped.y = clamp(Clamped.y, 0, NVENCSourceResolutionPlanar.y - 1);
        float4 Sampled = NVENCSourceTexture.Load(int3(Clamped, 0));
        float3 GammaCorrected = ApplyGammaByMode(Sampled.rgb, NVENCPlanarGammaMode);
        Colors[Index] = saturate(GammaCorrected);
    }

    const int2 DestBase = BlockCoord * 2 + NVENCOffsetPlanar;

    if (NVENCIs10Bit != 0)
    {
        WritePlanarLuma(DestBase, EncodeLuma10(Colors[0]));
        WritePlanarLuma(DestBase + int2(1, 0), EncodeLuma10(Colors[1]));
        WritePlanarLuma(DestBase + int2(0, 1), EncodeLuma10(Colors[2]));
        WritePlanarLuma(DestBase + int2(1, 1), EncodeLuma10(Colors[3]));
    }
    else
    {
        WritePlanarLuma(DestBase, EncodeLuma8(Colors[0]));
        WritePlanarLuma(DestBase + int2(1, 0), EncodeLuma8(Colors[1]));
        WritePlanarLuma(DestBase + int2(0, 1), EncodeLuma8(Colors[2]));
        WritePlanarLuma(DestBase + int2(1, 1), EncodeLuma8(Colors[3]));
    }

    float2 ChromaAccum = float2(0.0f, 0.0f);
    [unroll]
    for (int Index = 0; Index < 4; ++Index)
    {
        if (NVENCIs10Bit != 0)
        {
            ChromaAccum += EncodeChroma10(Colors[Index]);
        }
        else
        {
            ChromaAccum += EncodeChroma8(Colors[Index]);
        }
    }

    float2 Averaged = ChromaAccum * 0.25f;
    const int2 DestChromaCoord = BlockCoord + NVENCChromaOffset;
    if (DestChromaCoord.x >= 0 && DestChromaCoord.y >= 0 && DestChromaCoord.x < NVENCChromaResolution.x && DestChromaCoord.y < NVENCChromaResolution.y)
    {
        NVENCPlanarUVTexture[DestChromaCoord] = (uint2)round(Averaged);
    }
}
